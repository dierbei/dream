#### 创建任务入队过程
***
tokio 的工作单元被称为 task，当我们例如使用 sock 去接受一个连接并且处理请求的时候，
这就相当于一个任务，这个任务会被放入到一个运行队列中，
然后 processor 会从这个队列中取出任务进行运行
***
***
然后他第一个模型就是有一个 全局队列、多个 processor，当有任务产生的时候都会推到这个全局队列中。
处理器有多个，都会从这个全局队列中去取出 task。
这种实现方法比较粗暴，所有的 processor 都会从这个队列中取抢任务，容易造成锁竞争。
***
***
然后又提出了另外一种模型，每个 processor 都有自己运行队列。
这样做的好处就是避免了之前说的 task 竞争问题。
但是它也会出现一种意外情况，就是 task 分配不均。
因为除非 task 的分配是完全均衡的，要不然会出现 processor 空闲的情况。
也就相当于有的 processor 的运行队列  task 很多，有的很少，累的累死，闲的闲死
***
***
所以又提出了另外一种模型。当一个 processor 的运行队列为空的时候，他会去偷取其他 processor 的 task。
这样就可以避免分配不均的情况。
但是这个会遇到一个问题，当 processor A 尝试偷取队列，但是发现 processor B 当前正在运行一个 task，但是它的运行队列已经没有任务了。
processor A 就会进入睡眠，但是 processor B 当前正在执行的 task 可能会产生 20 个 task，这就出现了一些同步问题。
***
***
再之后又提出进行的优化：全局队列和独立运行队列混用，当运行队列已经满的时候，会将一半的 task 推送到全局队列中。
这样做的好处就是，可以避免搜索问题。因为之前那种每个 processor 一个运行队列的情况会出现多个 processor 去尝试搜索 task。
这个时候有可能又遇到大家都在偷一个队列的竞争问题。当 processor 达到处理器总数的一半就会尝试去全局队列偷取任务
***
***
全局 ==》独立 ==》 独立 + 全局
参考链接：https://tokio.rs/tokio/tutorial/select
***